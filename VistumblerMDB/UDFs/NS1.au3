#include-once
#include <FileConstants.au3>

; #INDEX# =======================================================================================================================
; Title .........: NS1 Library
; AutoIt Version : 3.3+
; Description ...: Functions for reading and writing NetStumbler .NS1 files (Version 12)
; Author(s) .....: Generated by Copilot
; ===============================================================================================================================

; ===============================================================================================================================
; Function Name:    _NS1_ReadFile
; Description:      Reads a .ns1 file into an array structure
; Parameter(s):     $sFilePath - Path to the .ns1 file
; Return Value(s):  Success - An array containing the File Version and an array of APs
;                   Failure - Sets @error
;                   @error 1 - File open failed
;                   @error 2 - Invalid Signature
;                   @error 3 - Unsupported Version (Only 12 supported currently)
; Format:           [Version, [AP1, AP2, ...]]
;                   AP Structure: [SSID, BSSID, MaxSignal, MinNoise, MaxSNR, Flags, BeaconInterval, FirstSeen, LastSeen, BestLat, BestLong, [DataPoints], Name, Channels, LastChannel, IPAddress, MinSignal, MaxNoise, DataRate, IPSubnet, IPMask, ApFlags, IEs]
;                   DataPoint: [Time, Signal, Noise, LocationSource, [Lat, Long, Alt, NumSats, Speed, Track, MagVar, Hdop]]
; ===============================================================================================================================
Func _NS1_ReadFile($sFilePath)
    Local $hFile = FileOpen($sFilePath, 16) ; $FO_BINARY
    If $hFile = -1 Then Return SetError(1, 0, 0)
    Local $bData = FileRead($hFile)
    FileClose($hFile)

    Local $iLen = BinaryLen($bData)
    Local $iPos = 1

    ; Header
    Local $sSig = BinaryToString(BinaryMid($bData, $iPos, 4))
    $iPos += 4
    If $sSig <> "NetS" Then Return SetError(2, 0, 0)

    Local $iVer = __NS1_GetUInt32($bData, $iPos)
    If $iVer <> 6 And $iVer <> 8 And $iVer <> 11 And $iVer <> 12 Then Return SetError(3, $iVer, 0)

    Local $iApCount = __NS1_GetUInt32($bData, $iPos)

    Local $aResult[2]
    $aResult[0] = $iVer
    Local $aAPs[$iApCount]

    For $i = 0 To $iApCount - 1
        If $iPos > $iLen Then ExitLoop

        Local $aAP[23] ; Standardize to V12 structure
        ; [0]SSID, [1]BSSID, [2]MaxSig, [3]MinNoise, [4]MaxSNR, [5]Flags, [6]BeaconInt, 
        ; [7]FirstSeen, [8]LastSeen, [9]BestLat, [10]BestLong, [11]DataPoints, [12]Name, 
        ; [13]Channels, [14]LastChannel, [15]IPAddress, [16]MinSignal, [17]MaxNoise, 
        ; [18]DataRate, [19]IPSubnet, [20]IPMask, [21]ApFlags, [22]IEs

        ; SSID
        Local $iSSIDLen = __NS1_GetUInt8($bData, $iPos)
        $aAP[0] = BinaryToString(BinaryMid($bData, $iPos, $iSSIDLen))
        $iPos += $iSSIDLen

        ; BSSID
        $aAP[1] = BinaryMid($bData, $iPos, 6)
        $iPos += 6

        ; Metrics
        $aAP[2] = __NS1_GetInt32($bData, $iPos) ; MaxSignal
        $aAP[3] = __NS1_GetInt32($bData, $iPos) ; MinNoise
        $aAP[4] = __NS1_GetInt32($bData, $iPos) ; MaxSNR
        
        If $iVer = 6 Then
             ; Version 6 has Channels32 here
             $aAP[13] = __NS1_GetUInt32($bData, $iPos) ; Channels (mapped to 64bit field)
        EndIf

        $aAP[5] = __NS1_GetUInt32($bData, $iPos) ; Flags
        $aAP[6] = __NS1_GetUInt32($bData, $iPos) ; BeaconInterval
        $aAP[7] = __NS1_GetInt64($bData, $iPos) ; FirstSeen
        $aAP[8] = __NS1_GetInt64($bData, $iPos) ; LastSeen
        $aAP[9] = __NS1_GetDouble($bData, $iPos) ; BestLat
        $aAP[10] = __NS1_GetDouble($bData, $iPos) ; BestLong

        ; Data Points
        Local $iDataCount = __NS1_GetUInt32($bData, $iPos)
        Local $aDataPoints[$iDataCount]
        For $j = 0 To $iDataCount - 1
            Local $aDP[5]
            $aDP[0] = __NS1_GetInt64($bData, $iPos) ; Time
            $aDP[1] = __NS1_GetInt32($bData, $iPos) ; Signal
            $aDP[2] = __NS1_GetInt32($bData, $iPos) ; Noise
            Local $iLocSource = __NS1_GetInt32($bData, $iPos)
            $aDP[3] = $iLocSource
            
            Local $aGPS[1] = [0]
            If $iLocSource = 1 Then
                Dim $aGPS[8]
                $aGPS[0] = __NS1_GetDouble($bData, $iPos) ; Lat
                $aGPS[1] = __NS1_GetDouble($bData, $iPos) ; Long
                $aGPS[2] = __NS1_GetDouble($bData, $iPos) ; Alt
                $aGPS[3] = __NS1_GetUInt32($bData, $iPos) ; Sats
                $aGPS[4] = __NS1_GetDouble($bData, $iPos) ; Speed
                $aGPS[5] = __NS1_GetDouble($bData, $iPos) ; Track
                $aGPS[6] = __NS1_GetDouble($bData, $iPos) ; MagVar
                $aGPS[7] = __NS1_GetDouble($bData, $iPos) ; Hdop
            EndIf
            $aDP[4] = $aGPS
            $aDataPoints[$j] = $aDP
        Next
        $aAP[11] = $aDataPoints

        ; Name
        Local $iNameLen = __NS1_GetUInt8($bData, $iPos)
        $aAP[12] = BinaryToString(BinaryMid($bData, $iPos, $iNameLen))
        $iPos += $iNameLen

        ; Fields after Name depend on Version
        If $iVer >= 8 Then
            $aAP[13] = __NS1_GetUInt64($bData, $iPos) ; Channels
            $aAP[14] = __NS1_GetUInt32($bData, $iPos) ; LastChannel
            $aAP[15] = __NS1_GetUInt32($bData, $iPos) ; IPAddress
        EndIf

        If $iVer >= 11 Then
             $aAP[16] = __NS1_GetInt32($bData, $iPos) ; MinSignal
             $aAP[17] = __NS1_GetInt32($bData, $iPos) ; MaxNoise
             $aAP[18] = __NS1_GetUInt32($bData, $iPos) ; DataRate
             $aAP[19] = __NS1_GetUInt32($bData, $iPos) ; IPSubnet
             $aAP[20] = __NS1_GetUInt32($bData, $iPos) ; IPMask
        EndIf

        If $iVer >= 12 Then
             $aAP[21] = __NS1_GetUInt32($bData, $iPos) ; ApFlags
             Local $iIELen = __NS1_GetUInt32($bData, $iPos)
             $aAP[22] = BinaryMid($bData, $iPos, $iIELen) ; IEs
             $iPos += $iIELen
        EndIf

        $aAPs[$i] = $aAP
    Next

    $aResult[1] = $aAPs
    Return $aResult
EndFunc

; ===============================================================================================================================
; Function Name:    _NS1_WriteFile
; Description:      Writes an NS1 file from an array structure (Version 12)
; Parameter(s):     $sFilePath - Path to write the .ns1 file
;                   $aData - Data array in the format returned by _NS1_ReadFile: [Version, [AP1, AP2, ...]]
; Return Value(s):  Success - 1
;                   Failure - Sets @error
;                   @error 1 - File open failed
; ===============================================================================================================================
Func _NS1_WriteFile($sFilePath, $aData)
    Local $hFile = FileOpen($sFilePath, 18) ; $FO_BINARY + $FO_OVERWRITE
    If $hFile = -1 Then Return SetError(1, 0, 0)
    
    Local $bData = Binary("")
    
    ; Header
    $bData &= StringToBinary("NetS")
    $bData &= __NS1_ToUInt32(12) ; Always write version 12
    
    Local $aAPs = $aData[1]
    Local $iApCount = UBound($aAPs)
    $bData &= __NS1_ToUInt32($iApCount)
    
    FileWrite($hFile, $bData)
    $bData = Binary("") ; Clear buffer to save memory, will write APs one by one or in chunks
    
    For $i = 0 To $iApCount - 1
        Local $aAP = $aAPs[$i]
        Local $bAP = Binary("")
        
        ; SSID
        Local $sSSID = $aAP[0]
        Local $iSSIDLen = StringLen($sSSID)
        $bAP &= __NS1_ToUInt8($iSSIDLen)
        $bAP &= StringToBinary($sSSID)
        
        ; BSSID
        $bAP &= $aAP[1]
        
        ; Metrics
        $bAP &= __NS1_ToInt32($aAP[2]) ; MaxSignal
        $bAP &= __NS1_ToInt32($aAP[3]) ; MinNoise
        $bAP &= __NS1_ToInt32($aAP[4]) ; MaxSNR
        $bAP &= __NS1_ToUInt32($aAP[5]) ; Flags
        $bAP &= __NS1_ToUInt32($aAP[6]) ; BeaconInterval
        $bAP &= __NS1_ToInt64($aAP[7]) ; FirstSeen
        $bAP &= __NS1_ToInt64($aAP[8]) ; LastSeen
        $bAP &= __NS1_ToDouble($aAP[9]) ; BestLat
        $bAP &= __NS1_ToDouble($aAP[10]) ; BestLong
        
        ; Data Points
        Local $aDataPoints = $aAP[11]
        If IsArray($aDataPoints) Then
            Local $iDataCount = UBound($aDataPoints)
            $bAP &= __NS1_ToUInt32($iDataCount)
            For $j = 0 To $iDataCount - 1
                Local $aDP = $aDataPoints[$j]
                $bAP &= __NS1_ToInt64($aDP[0]) ; Time
                $bAP &= __NS1_ToInt32($aDP[1]) ; Signal
                $bAP &= __NS1_ToInt32($aDP[2]) ; Noise
                Local $iLocSource = $aDP[3]
                $bAP &= __NS1_ToInt32($iLocSource)
                
                If $iLocSource = 1 Then
                     Local $aGPS = $aDP[4]
                     $bAP &= __NS1_ToDouble($aGPS[0]) ; Lat
                     $bAP &= __NS1_ToDouble($aGPS[1]) ; Long
                     $bAP &= __NS1_ToDouble($aGPS[2]) ; Alt
                     $bAP &= __NS1_ToUInt32($aGPS[3]) ; Sats
                     $bAP &= __NS1_ToDouble($aGPS[4]) ; Speed
                     $bAP &= __NS1_ToDouble($aGPS[5]) ; Track
                     $bAP &= __NS1_ToDouble($aGPS[6]) ; MagVar
                     $bAP &= __NS1_ToDouble($aGPS[7]) ; Hdop
                EndIf
            Next
        Else
             $bAP &= __NS1_ToUInt32(0)
        EndIf
        
        ; Name
        Local $sName = $aAP[12]
        Local $iNameLen = StringLen($sName)
        $bAP &= __NS1_ToUInt8($iNameLen)
        $bAP &= StringToBinary($sName)
        
        ; More fields
        $bAP &= __NS1_ToUInt64($aAP[13]) ; Channels
        $bAP &= __NS1_ToUInt32($aAP[14]) ; LastChannel
        $bAP &= __NS1_ToUInt32($aAP[15]) ; IPAddress
        $bAP &= __NS1_ToInt32($aAP[16]) ; MinSignal
        $bAP &= __NS1_ToInt32($aAP[17]) ; MaxNoise
        $bAP &= __NS1_ToUInt32($aAP[18]) ; DataRate
        $bAP &= __NS1_ToUInt32($aAP[19]) ; IPSubnet
        $bAP &= __NS1_ToUInt32($aAP[20]) ; IPMask
        $bAP &= __NS1_ToUInt32($aAP[21]) ; ApFlags
        
        Local $bIEs = $aAP[22]
        Local $iIELen = BinaryLen($bIEs)
        $bAP &= __NS1_ToUInt32($iIELen)
        $bAP &= $bIEs
        
        FileWrite($hFile, $bAP)
    Next
    
    FileClose($hFile)
    Return 1
EndFunc


; ===============================================================================================================================
; Helper functions to read types
; ===============================================================================================================================
Func __NS1_GetUInt8(ByRef $b, ByRef $p)
    Local $t = DllStructCreate("byte")
    DllStructSetData($t, 1, BinaryMid($b, $p, 1))
    $p += 1
    Return DllStructGetData($t, 1)
EndFunc

Func __NS1_GetUInt32(ByRef $b, ByRef $p)
    Local $t = DllStructCreate("uint")
    DllStructSetData($t, 1, BinaryMid($b, $p, 4))
    $p += 4
    Return DllStructGetData($t, 1)
EndFunc

Func __NS1_GetInt32(ByRef $b, ByRef $p)
    Local $t = DllStructCreate("int")
    DllStructSetData($t, 1, BinaryMid($b, $p, 4))
    $p += 4
    Return DllStructGetData($t, 1)
EndFunc

Func __NS1_GetInt64(ByRef $b, ByRef $p)
    Local $t = DllStructCreate("int64")
    DllStructSetData($t, 1, BinaryMid($b, $p, 8))
    $p += 8
    Return DllStructGetData($t, 1)
EndFunc

Func __NS1_GetUInt64(ByRef $b, ByRef $p)
    Local $t = DllStructCreate("uint64")
    DllStructSetData($t, 1, BinaryMid($b, $p, 8))
    $p += 8
    Return DllStructGetData($t, 1)
EndFunc

Func __NS1_GetDouble(ByRef $b, ByRef $p)
    Local $bChunk = BinaryMid($b, $p, 8)
    $p += 8
    Local $t = DllStructCreate("double")
    Local $tBuffer = DllStructCreate("byte[8]", DllStructGetPtr($t))
    DllStructSetData($tBuffer, 1, $bChunk)
    Return DllStructGetData($t, 1)
EndFunc

; ===============================================================================================================================
; Helper functions to write types
; ===============================================================================================================================
Func __NS1_StructToBinary($tStruct)
    Local $tBuffer = DllStructCreate("byte[" & DllStructGetSize($tStruct) & "]", DllStructGetPtr($tStruct))
    Return DllStructGetData($tBuffer, 1)
EndFunc

Func __NS1_ToUInt8($v)
    Local $t = DllStructCreate("byte")
    DllStructSetData($t, 1, $v)
    Return __NS1_StructToBinary($t)
EndFunc

Func __NS1_ToUInt32($v)
    Local $t = DllStructCreate("uint")
    DllStructSetData($t, 1, $v)
    Return __NS1_StructToBinary($t)
EndFunc

Func __NS1_ToInt32($v)
    Local $t = DllStructCreate("int")
    DllStructSetData($t, 1, $v)
    Return __NS1_StructToBinary($t)
EndFunc

Func __NS1_ToInt64($v)
    Local $t = DllStructCreate("int64")
    DllStructSetData($t, 1, $v)
    Return __NS1_StructToBinary($t)
EndFunc

Func __NS1_ToUInt64($v)
    Local $t = DllStructCreate("uint64")
    DllStructSetData($t, 1, $v)
    Return __NS1_StructToBinary($t)
EndFunc

Func __NS1_ToDouble($v)
    Local $t = DllStructCreate("double")
    DllStructSetData($t, 1, Number($v))
    Return __NS1_StructToBinary($t)
EndFunc

; ===============================================================================================================================
; Helper: Convert Date/Time string to FILETIME (Int64)
; Input: YYYY-MM-DD, HH:MM:SS
; ===============================================================================================================================
Func _NS1_DateToFILETIME($sDate, $sTime)
    ; Vistumbler dates are typically YYYY-MM-DD or YYYY/MM/DD
    $sDate = StringReplace($sDate, "-", "/")
    $sTime = StringLeft($sTime, 8) ; Ensure HH:MM:SS
    
    ; Calculate seconds since Jan 1 1601 (UTC)
    ; Assuming input is Local Time, we might need to adjust. For now treating as is or basic conversion.
    ; _DateDiff returns Int32 usually, but for 1601 it might be large.
    ; AutoIt's _DateDiff works from 100 to 9999.
    
    Local $iSecs = _DateDiff("s", "1601/01/01 00:00:00", $sDate & " " & $sTime)
    
    ; Convert to 100-nanosecond intervals (x 10,000,000)
    Local $iFileTime = $iSecs * 10000000
    Return $iFileTime
EndFunc

; ===============================================================================================================================
; Helper: Convert FILETIME (Int64) to Vistumbler Date/Time strings
; Return: Array [Date (YYYY-MM-DD), Time (HH:MM:SS)]
; ===============================================================================================================================
Func _NS1_FileTimeToDate($iFileTime)
    If $iFileTime = 0 Then Return "1601/01/01 00:00:00"
    
    ; Convert 100ns units to seconds
    Local $iSecs = Floor($iFileTime / 10000000)
    
    ; Add to base date 1601/01/01
    Local $sNewDate = _DateAdd("s", $iSecs, "1601/01/01 00:00:00")
    
    If @error Then Return "1601/01/01 00:00:00"
    
    Return $sNewDate
EndFunc

