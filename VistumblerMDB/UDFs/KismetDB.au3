#include-once
#include <SQLite.au3>
#include "JSON.au3"

; #INDEX# =======================================================================================================================
; Title .........: KismetDB Library
; AutoIt Version : 3.3.14.0+
; Description ...: Functions for writing KismetDB (.kismet) files (Version 10)
; Author(s) .....: Generated by Copilot
; ===============================================================================================================================

; ===============================================================================================================================
; Function Name:    _KismetDB_Create
; Description:      Creates a new KismetDB file and initializes the schema (Version 10)
; Parameter(s):     $sFilePath - Path to the .kismet file
; Return Value(s):  Success - A handle to the SQLite database
;                   Failure - 0 and sets @error
; ===============================================================================================================================
Func _KismetDB_Create($sFilePath)
    _SQLite_Startup()
    Local $hDB = _SQLite_Open($sFilePath)
    If @error Then Return SetError(1, 0, 0)

    _SQLite_Exec($hDB, "BEGIN TRANSACTION;")

    ; KISMET table
    _SQLite_Exec($hDB, "CREATE TABLE KISMET (kismet_version TEXT, db_version INTEGER, db_module TEXT);")
    _SQLite_Exec($hDB, "INSERT INTO KISMET (kismet_version, db_version, db_module) VALUES ('2023-07', 10, 'kismetlog');")

    ; ALERTS table
    _SQLite_Exec($hDB, "CREATE TABLE alerts (ts_sec INTEGER, ts_usec INTEGER, phyname TEXT, devmac TEXT, lat REAL, lon REAL, header TEXT, json BLOB);")

    ; DATA table
    _SQLite_Exec($hDB, "CREATE TABLE data (ts_sec INTEGER, ts_usec INTEGER, phyname TEXT, devmac TEXT, lat REAL, lon REAL, alt REAL, speed REAL, heading REAL, datasource TEXT, type TEXT, json BLOB, signal INTEGER);")

    ; DATASOURCE table
    _SQLite_Exec($hDB, "CREATE TABLE datasources (uuid TEXT, typestring TEXT, definition TEXT, name TEXT, interface TEXT, json BLOB, UNIQUE(uuid) ON CONFLICT REPLACE);")
    _SQLite_Exec($hDB, "INSERT INTO datasources (uuid, typestring, definition, name, interface, json) VALUES ('00000000-0000-0000-0000-000000000000', 'vistumbler', 'vistumbler', 'vistumbler', 'vistumbler', '{}');")

    ; DEVICES table
    _SQLite_Exec($hDB, "CREATE TABLE devices (first_time INTEGER, last_time INTEGER, devkey TEXT, phyname TEXT, devmac TEXT, strongest_signal INTEGER, min_lat REAL, min_lon REAL, max_lat REAL, max_lon REAL, avg_lat REAL, avg_lon REAL, bytes_data INTEGER, type TEXT, device BLOB, UNIQUE(phyname, devmac) ON CONFLICT REPLACE);")
    _SQLite_Exec($hDB, "CREATE INDEX idx_devices_devkey ON devices(devkey);")
    _SQLite_Exec($hDB, "CREATE INDEX idx_devices_devmac ON devices(devmac);")

    ; MESSAGES table
    _SQLite_Exec($hDB, "CREATE TABLE messages (ts_sec INTEGER, lat REAL, lon REAL, alt REAL, speed REAL, heading REAL, msgtype TEXT, message TEXT);")

    ; PACKETS table (Version 10)
    _SQLite_Exec($hDB, "CREATE TABLE packets (ts_sec INTEGER, ts_usec INTEGER, phyname TEXT, sourcemac TEXT, destmac TEXT, transmac TEXT, frequency REAL, devkey TEXT, lat REAL, lon REAL, alt REAL, speed REAL, heading REAL, packet_len INTEGER, signal INTEGER, datasource TEXT, dlt INTEGER, packet BLOB, error INTEGER, tags TEXT, datarate REAL, hash INTEGER, packetid INTEGER, packet_full_len INTEGER);")
    _SQLite_Exec($hDB, "CREATE INDEX idx_packets_sourcemac ON packets(sourcemac);")

    ; SNAPSHOTS table
    _SQLite_Exec($hDB, "CREATE TABLE snapshots (ts_sec INTEGER, ts_usec INTEGER, lat REAL, lon REAL, snaptype TEXT, json TEXT);")

    _SQLite_Exec($hDB, "COMMIT;")

    Return $hDB
EndFunc

; ===============================================================================================================================
; Function Name:    _KismetDB_AddDevice
; Description:      Adds a device to the KismetDB
; ===============================================================================================================================
Func _KismetDB_AddDevice($hDB, $first_time, $last_time, $devkey, $phyname, $devmac, $strongest_signal, $min_lat, $min_lon, $max_lat, $max_lon, $avg_lat, $avg_lon, $bytes_data, $type, $sDeviceJson)
    Local $sQuery = "INSERT INTO devices (first_time, last_time, devkey, phyname, devmac, strongest_signal, min_lat, min_lon, max_lat, max_lon, avg_lat, avg_lon, bytes_data, type, device) VALUES (" & _
        $first_time & ", " & _
        $last_time & ", " & _
        _SQLite_Escape($devkey) & ", " & _
        _SQLite_Escape($phyname) & ", " & _
        _SQLite_Escape($devmac) & ", " & _
        $strongest_signal & ", " & _
        $min_lat & ", " & _
        $min_lon & ", " & _
        $max_lat & ", " & _
        $max_lon & ", " & _
        $avg_lat & ", " & _
        $avg_lon & ", " & _
        $bytes_data & ", " & _
        _SQLite_Escape($type) & ", " & _
        _SQLite_Escape($sDeviceJson) & ");"
    
    _SQLite_Exec($hDB, $sQuery)
    Return
EndFunc

; ===============================================================================================================================
; Function Name:    _KismetDB_AddPacket
; Description:      Adds a packet to the KismetDB
; ===============================================================================================================================
; ===============================================================================================================================
; Function Name:    _KismetDB_AddPacket
; Description:      Adds a packet to the KismetDB
; ===============================================================================================================================
Func _KismetDB_AddPacket($hDB, $ts_sec, $ts_usec, $phyname, $sourcemac, $destmac, $transmac, $frequency, $lat, $lon, $signal, $datasource, $dlt, $error, $packetid, $packet_data, $packet_len, $tags = "")
    ; $packet_data should be a hex string like "0A0B0C..."
    Local $sBlob = "X''"
    If $packet_data <> "" Then
        $sBlob = "X'" & $packet_data & "'"
    EndIf

    Local $sQuery = "INSERT INTO packets (ts_sec, ts_usec, phyname, sourcemac, destmac, transmac, frequency, devkey, lat, lon, alt, speed, heading, packet_len, signal, datasource, dlt, packet, error, tags, datarate, hash, packetid, packet_full_len) VALUES (" & _
        $ts_sec & ", " & _
        0 & ", " & _
        _SQLite_Escape($phyname) & ", " & _
        _SQLite_Escape($sourcemac) & ", " & _
        _SQLite_Escape($destmac) & ", " & _
        _SQLite_Escape($transmac) & ", " & _
        $frequency & ", " & _
        "''" & ", " & _ ; devkey
        $lat & ", " & _
        $lon & ", " & _
        0 & ", " & _ ; alt
        0 & ", " & _ ; speed
        0 & ", " & _ ; heading
        $packet_len & ", " & _ ; packet_len
        $signal & ", " & _
        _SQLite_Escape($datasource) & ", " & _
        $dlt & ", " & _
        $sBlob & ", " & _ ; Packet BLOB
        $error & ", " & _
        _SQLite_Escape($tags) & ", " & _ ; tags (used by Vistumbler for original signal%)
        0 & ", " & _ ; datarate
        0 & ", " & _ ; hash
        $packetid & ", " & _ 
        $packet_len & ");" ; packet_full_len
    
    _SQLite_Exec($hDB, $sQuery)
    Return
EndFunc

; ===============================================================================================================================
; Function Name:    _KismetDB_GenerateRadiotapBeacon
; Description:      Generates a Hex String of a Radiotap Header + 802.11 Beacon Frame
;                   with proper IE tags for SSID, Channel, Encryption (RSN/WPA)
; ===============================================================================================================================
Func _KismetDB_GenerateRadiotapBeacon($sBSSID, $sSSID, $iChannel, $iFreq, $iSignal, $sRatesHex, $iPrivacy = 0, $sAuth = "", $sEncr = "")
    Local $sHex = ""
    
    ; --- Radiotap Header ---
    ; Ver(1) + Pad(1) + Len(2) + Present(4)
    ; Channel(4) + Signal(1)
    ; Total Header Length = 8 + 4 + 1 = 13 bytes
    ; Radiotap fields:
    ; Channel (Bit 3) = 2 bytes freq + 2 bytes flags
    ; Signal (Bit 5) = 1 byte dBm
    
    Local $iHeaderLen = 13
    
    ; Header: Ver=0, Pad=0, Len=13, Present=0x28 (Chan+Sig) -> Little Endian 28 00 00 00
    $sHex &= "0000" & _KismetDB_HexSwap(Hex($iHeaderLen, 4)) & "28000000"
    
    ; Field: Channel (Freq 2 bytes LE, Flags 2 bytes LE)
    ; Channel flags: 0x00A0 = 5GHz+OFDM, 0x00B0 = 2GHz+CCK, 0x00C0 = 2GHz+OFDM
    Local $iChanFlags = 0x0000
    If $iChannel <= 14 Then
        $iChanFlags = 0x00B0 ; 2GHz + CCK
    Else
        $iChanFlags = 0x0140 ; 5GHz + OFDM
    EndIf
    $sHex &= _KismetDB_HexSwap(Hex(Int($iFreq), 4)) & _KismetDB_HexSwap(Hex(Int($iChanFlags), 4))
    
    ; Field: Signal (1 byte signed dBm)
    Local $hSig = Hex($iSignal, 2)
    $sHex &= $hSig
    
    ; --- 802.11 Beacon Frame ---
    
    ; Frame Control: Type 0 (Mgmt), Subtype 8 (Beacon) = 0x80, Flags 0x00
    $sHex &= "8000"
    
    ; Duration: 0
    $sHex &= "0000"
    
    ; Addr1 (Dest): Broadcast
    $sHex &= "FFFFFFFFFFFF"
    
    ; Addr2 (Src): BSSID
    Local $sMacRaw = StringReplace($sBSSID, ":", "")
    If StringLen($sMacRaw) <> 12 Then $sMacRaw = "000000000000"
    $sHex &= $sMacRaw
    
    ; Addr3 (BSSID): BSSID
    $sHex &= $sMacRaw
    
    ; Seq Ctrl: 0
    $sHex &= "0000"
    
    ; --- Frame Body ---
    
    ; Timestamp (8 bytes)
    $sHex &= "0000000000000000"
    
    ; Beacon Interval (2 bytes LE). 100 TU (0x0064)
    $sHex &= "6400"
    
    ; Capabilities (2 bytes LE).
    ; ESS (0x0001) + Short Preamble (0x0020) = 0x0021
    ; If Privacy (Bit 4, 0x0010), then 0x0031
    Local $iCap = 0x0021
    If $iPrivacy Then $iCap = 0x0031
    $sHex &= _KismetDB_HexSwap(Hex($iCap, 4))
    
    ; --- Information Elements ---
    
    ; IE 0: SSID Parameter Set
    Local $sSSIDHex = _KismetDB_StringToHex($sSSID)
    Local $iSSIDLen = Int(StringLen($sSSIDHex) / 2)
    $sHex &= "00" & Hex($iSSIDLen, 2) & $sSSIDHex

    ; Retrieve Rates Tags
    Local $aRates = _KismetDB_GenerateRatesTags($sRatesHex)
    
    ; IE 1: Supported Rates
    $sHex &= $aRates[0]
    
    ; IE 3: DS Parameter Set (Channel) - Added for ALL channels
    ; Kismet reads channel from this IE tag; for 5GHz channels > 255, use modulo
    $sHex &= "0301" & Hex(BitAND($iChannel, 0xFF), 2)
    
    ; IE 50: Extended Supported Rates
    If $aRates[1] <> "" Then
        $sHex &= $aRates[1]
    EndIf
    
    ; IE 48: RSN Information Element (for WPA2/WPA3)
    If StringInStr($sAuth, "WPA2") Or StringInStr($sEncr, "WPA2") Or StringInStr($sAuth, "WPA3") Or StringInStr($sEncr, "WPA3") Then
        $sHex &= _KismetDB_GenerateRSN_IE($sAuth, $sEncr)
    EndIf
    
    ; IE 221: Vendor Specific - WPA (for WPA1)
    If (StringInStr($sAuth, "WPA") And Not StringInStr($sAuth, "WPA2") And Not StringInStr($sAuth, "WPA3")) Or _
       (StringInStr($sEncr, "WPA") And Not StringInStr($sEncr, "WPA2") And Not StringInStr($sEncr, "WPA3")) Then
        $sHex &= _KismetDB_GenerateWPA_VendorIE($sAuth, $sEncr)
    EndIf
    
    ; Handle mixed WPA/WPA2 - if Auth contains both "WPA2" and "WPA", add both
    If StringInStr($sAuth, "WPA2") And StringInStr($sAuth, "WPA") And StringInStr($sAuth, "/") Then
        ; WPA2 RSN IE already added above, add WPA1 vendor IE too
        If Not (StringInStr($sAuth, "WPA") And Not StringInStr($sAuth, "WPA2")) Then
            $sHex &= _KismetDB_GenerateWPA_VendorIE($sAuth, $sEncr)
        EndIf
    EndIf
    
    Return $sHex
EndFunc

; ===============================================================================================================================
; Function Name:    _KismetDB_GenerateRSN_IE
; Description:      Generates IE Tag 48 (RSN Information Element) for WPA2
;                   Binary format: Version(2) + GroupCipher(4) + PairwiseCount(2) + PairwiseCiphers(4*N)
;                                  + AKMCount(2) + AKMSuites(4*M) + RSNCapabilities(2)
;                   OUI for RSN: 00:0F:AC
;                   Cipher types: 2=TKIP, 4=CCMP
;                   AKM types: 1=802.1X, 2=PSK
; ===============================================================================================================================
Func _KismetDB_GenerateRSN_IE($sAuth, $sEncr)
    Local $sBody = ""
    Local $sRsnOUI = "000FAC"
    
    ; RSN Version: 1 (LE)
    $sBody &= "0100"
    
    ; Group Cipher Suite: OUI + Type
    If StringInStr($sEncr, "CCMP") Or StringInStr($sEncr, "AES") Then
        $sBody &= $sRsnOUI & "04" ; CCMP-128
    ElseIf StringInStr($sEncr, "TKIP") Then
        $sBody &= $sRsnOUI & "02" ; TKIP
    Else
        $sBody &= $sRsnOUI & "04" ; Default to CCMP
    EndIf
    
    ; Pairwise Cipher Suite Count: 1 (LE)
    $sBody &= "0100"
    
    ; Pairwise Cipher Suite: OUI + Type
    If StringInStr($sEncr, "CCMP") Or StringInStr($sEncr, "AES") Then
        $sBody &= $sRsnOUI & "04" ; CCMP-128
    ElseIf StringInStr($sEncr, "TKIP") Then
        $sBody &= $sRsnOUI & "02" ; TKIP
    Else
        $sBody &= $sRsnOUI & "04" ; Default to CCMP
    EndIf
    
    ; AKM Suite Count: 1 (LE)
    $sBody &= "0100"
    
    ; AKM Suite: OUI + Type
    If StringInStr($sAuth, "WPA3") And (StringInStr($sAuth, "PSK") Or StringInStr($sAuth, "Personal")) Then
        $sBody &= $sRsnOUI & "08" ; SAE (WPA3-Personal)
    ElseIf StringInStr($sAuth, "PSK") Or StringInStr($sAuth, "Personal") Then
        $sBody &= $sRsnOUI & "02" ; PSK
    Else
        $sBody &= $sRsnOUI & "01" ; 802.1X (Enterprise)
    EndIf
    
    ; RSN Capabilities: 0x0000
    $sBody &= "0000"
    
    ; Tag header: Tag=48 (0x30), Length
    Local $iBodyLen = Int(StringLen($sBody) / 2)
    Return "30" & Hex($iBodyLen, 2) & $sBody
EndFunc

; ===============================================================================================================================
; Function Name:    _KismetDB_GenerateWPA_VendorIE
; Description:      Generates IE Tag 221 (Vendor Specific) for WPA1
;                   OUI: 00:50:F2, Type: 01
;                   Binary: OUI(3) + OUIType(1) + Version(2) + MulticastCipher(4)
;                           + UnicastCount(2) + UnicastCiphers(4*N) + AKMCount(2) + AKMSuites(4*M)
;                   Cipher types: 2=TKIP, 4=CCMP
;                   AKM types: 1=802.1X, 2=PSK
; ===============================================================================================================================
Func _KismetDB_GenerateWPA_VendorIE($sAuth, $sEncr)
    Local $sBody = ""
    Local $sWpaOUI = "0050F2"
    
    ; OUI + OUI Type (WPA)
    $sBody &= $sWpaOUI & "01"
    
    ; WPA Version: 1 (LE)
    $sBody &= "0100"
    
    ; Multicast Cipher Suite: OUI + Type
    If StringInStr($sEncr, "TKIP") Then
        $sBody &= $sWpaOUI & "02" ; TKIP
    ElseIf StringInStr($sEncr, "CCMP") Or StringInStr($sEncr, "AES") Then
        $sBody &= $sWpaOUI & "04" ; CCMP
    Else
        $sBody &= $sWpaOUI & "02" ; Default to TKIP for WPA1
    EndIf
    
    ; Unicast Cipher Suite Count: 1 (LE)
    $sBody &= "0100"
    
    ; Unicast Cipher Suite: OUI + Type
    If StringInStr($sEncr, "TKIP") Then
        $sBody &= $sWpaOUI & "02" ; TKIP
    ElseIf StringInStr($sEncr, "CCMP") Or StringInStr($sEncr, "AES") Then
        $sBody &= $sWpaOUI & "04" ; CCMP
    Else
        $sBody &= $sWpaOUI & "02" ; Default to TKIP
    EndIf
    
    ; AKM Suite Count: 1 (LE)
    $sBody &= "0100"
    
    ; AKM Suite: OUI + Type
    If StringInStr($sAuth, "PSK") Or StringInStr($sAuth, "Personal") Then
        $sBody &= $sWpaOUI & "02" ; PSK
    Else
        $sBody &= $sWpaOUI & "01" ; 802.1X
    EndIf
    
    ; Tag header: Tag=221 (0xDD), Length
    Local $iBodyLen = Int(StringLen($sBody) / 2)
    Return "DD" & Hex($iBodyLen, 2) & $sBody
EndFunc

; Helper to Generate Rates Hex Strings (Tag 1 and Tag 50)
; Returns an Array [Tag1HexHeader+Body, Tag50HexHeader+Body]
Func _KismetDB_GenerateRatesTags($sBasicRates, $sOtherRates = "")
    Local $sTag1 = ""
    Local $sTag50 = ""
    Local $iTag1Len = 0
    Local $iTag50Len = 0
    
    ; Support legacy call where single string is passed? No, caller changed.
    ; If sOtherRates is empty, split sBasicRates?
    If $sOtherRates = "" And StringInStr($sBasicRates, "|") Then
        Local $aSplit = StringSplit($sBasicRates, "|")
        $sBasicRates = $aSplit[1]
        $sOtherRates = $aSplit[2]
    EndIf
    
    ; Clean input
    $sBasicRates = StringReplace($sBasicRates, " ", "")
    $sOtherRates = StringReplace($sOtherRates, " ", "")
    
    Local $aBasic = StringSplit($sBasicRates, ",")
    Local $aOther = StringSplit($sOtherRates, ",")
    
    ; Process Basic Rates (Tag 1 - Supported Rates) -> Max 8 bytes
    For $i = 1 To $aBasic[0]
        If $aBasic[$i] == "" Then ContinueLoop
        Local $iRate = Int(Number($aBasic[$i]) * 2)
        ; Set Basic Rate Bit (0x80)
        $iRate = BitOR($iRate, 128)
        
        If $iTag1Len < 8 Then
            $sTag1 &= Hex($iRate, 2)
            $iTag1Len += 1
        Else
            $sTag50 &= Hex($iRate, 2)
            $iTag50Len += 1
        EndIf
    Next
    
    ; Process Other Rates (Tag 50 - Extended Supported Rates)
    For $i = 1 To $aOther[0]
        If $aOther[$i] == "" Then ContinueLoop
        Local $iRate = Int(Number($aOther[$i]) * 2)
        
        If $iTag1Len < 8 Then
             ; If we haven't filled Tag 1, put it there (Bit 7 cleared)
            $sTag1 &= Hex($iRate, 2)
            $iTag1Len += 1
        Else
            $sTag50 &= Hex($iRate, 2)
            $iTag50Len += 1
        EndIf
    Next
    
    Local $sRetTag1 = ""
    Local $sRetTag50 = ""

    ; If no rates found, use default
    If $iTag1Len = 0 Then
         $sRetTag1 = "010882848b960c121824" ; Default: 1(B), 2(B), 5.5(B), 11(B), 6, 9, 12, 18
    Else
         $sRetTag1 = "01" & Hex($iTag1Len, 2) & $sTag1
    EndIf
    
    If $iTag50Len > 0 Then
        $sRetTag50 = "32" & Hex($iTag50Len, 2) & $sTag50
    EndIf
    
    Local $aRet[2]
    $aRet[0] = $sRetTag1
    $aRet[1] = $sRetTag50
    
    Return $aRet
EndFunc

; Helper to Swap Endianness (2 chars per byte)
Func _KismetDB_HexSwap($sHex)
    Local $sRet = ""
    Local $iLen = StringLen($sHex)
    For $i = $iLen - 1 To 1 Step -2
        $sRet &= StringMid($sHex, $i, 2)
    Next
    Return $sRet
EndFunc

; Helper string to hex
Func _KismetDB_StringToHex($sString)
    Local $sHex = ""
    For $i = 1 To StringLen($sString)
        $sHex &= Hex(Asc(StringMid($sString, $i, 1)), 2)
    Next
    Return $sHex
EndFunc

; ===============================================================================================================================
; Function Name:    _KismetDB_Close
; Description:      Closes the KismetDB file
; ===============================================================================================================================
Func _KismetDB_Close($hDB)
    _SQLite_Close($hDB)
EndFunc

; Function Name:    _KismetDB_GetCryptBitfield
; Description:      Converts encryption string to Kismet Bitfield
; ===============================================================================================================================
Func _KismetDB_GetCryptBitfield($sAuth, $sEncr)
    ; Bit definitions from Kismet packet_ieee80211.h
    Local $dot11_crypt_general_wep          = 1 
    Local $dot11_crypt_general_wpa          = 2
    Local $dot11_crypt_general_wpa1         = 4
    Local $dot11_crypt_general_wpa2         = 8
    
    Local $dot11_crypt_group_wep104         = 256
    Local $dot11_crypt_group_tkip           = 512
    Local $dot11_crypt_group_ccmp128        = 1024
    
    Local $dot11_crypt_pairwise_wep104      = 16777216
    Local $dot11_crypt_pairwise_tkip        = 33554432
    Local $dot11_crypt_pairwise_ccmp128     = 67108864
    
    Local $dot11_crypt_akm_1x               = 137438953472
    Local $dot11_crypt_akm_psk              = 274877906944
    
    Local $iBitfield = 0
    
    If StringInStr($sEncr, "WEP") Then
        $iBitfield = BitOR($iBitfield, $dot11_crypt_general_wep, $dot11_crypt_group_wep104, $dot11_crypt_pairwise_wep104)
    EndIf
    
    If StringInStr($sEncr, "CCMP") Or StringInStr($sEncr, "AES") Then
        $iBitfield = BitOR($iBitfield, $dot11_crypt_group_ccmp128, $dot11_crypt_pairwise_ccmp128)
    EndIf
    
    If StringInStr($sEncr, "TKIP") Then
        $iBitfield = BitOR($iBitfield, $dot11_crypt_group_tkip, $dot11_crypt_pairwise_tkip)
    EndIf
    
    If StringInStr($sAuth, "WPA2") Or StringInStr($sEncr, "WPA2") Then
        $iBitfield = BitOR($iBitfield, $dot11_crypt_general_wpa, $dot11_crypt_general_wpa2)
        If StringInStr($sAuth, "PSK") Or StringInStr($sAuth, "Personal") Then
            $iBitfield = BitOR($iBitfield, $dot11_crypt_akm_psk)
        Else
            $iBitfield = BitOR($iBitfield, $dot11_crypt_akm_1x)
        EndIf
    ElseIf StringInStr($sAuth, "WPA") Or StringInStr($sEncr, "WPA") Then
         $iBitfield = BitOR($iBitfield, $dot11_crypt_general_wpa, $dot11_crypt_general_wpa1)
         If StringInStr($sAuth, "PSK") Or StringInStr($sAuth, "Personal") Then
            $iBitfield = BitOR($iBitfield, $dot11_crypt_akm_psk)
        Else
            $iBitfield = BitOR($iBitfield, $dot11_crypt_akm_1x)
        EndIf
    EndIf
    
    Return $iBitfield
EndFunc

; ===============================================================================================================================
; Function Name:    _KismetDB_GenerateDeviceJSON
; Description:      Generates a basic Device JSON structure with Dot11 extensions
; ===============================================================================================================================
Func _KismetDB_GenerateDeviceJSON($devkey, $devmac, $type, $phyname, $ssid, $channel, $manuf, $encryption, $iCryptSet, $iFreqKhz = 0, $sRadioType = "")
    ; Compute SSID checksum for the advertised_ssid_map key
    ; Kismet uses xxHash of ssid+length but for compatibility we use a simple hash
    Local $iSSIDCsum = 0
    For $c = 1 To StringLen($ssid)
        $iSSIDCsum = BitXOR($iSSIDCsum * 31, Asc(StringMid($ssid, $c, 1)))
    Next
    If $iSSIDCsum < 0 Then $iSSIDCsum = $iSSIDCsum * -1
    Local $sSSIDCsumKey = String($iSSIDCsum)

    ; Create the Advertised SSID Record
    Local $oSSIDRecord = _JSONObject( _
        "dot11.advertisedssid.ssid", $ssid, _
        "dot11.advertisedssid.ssidlen", StringLen($ssid), _
        "dot11.advertisedssid.ssid_len", StringLen($ssid), _
        "dot11.advertisedssid.length", StringLen($ssid), _
        "dot11.advertisedssid.crypt_set", $iCryptSet, _
        "dot11.advertisedssid.crypt_bitfield", $iCryptSet, _
        "dot11.advertisedssid.channel", String($channel), _
        "dot11.advertisedssid.beacon_info", "", _
        "dot11.advertisedssid.first_time", 0, _
        "dot11.advertisedssid.last_time", 0 _
    )

    ; Create the Advertised SSID Map (keyed by ssid checksum)
    Local $oSSIDMap = _JSONObject($sSSIDCsumKey, $oSSIDRecord)

    ; Create the Dot11 Device Object
    Local $oDot11 = _JSONObject( _
        "dot11.device.last_beaconed_ssid", $ssid, _
        "dot11.device.last_beaconed_ssid_record", $oSSIDRecord, _
        "dot11.device.last_beaconed_ssid_checksum", $iSSIDCsum, _
        "dot11.device.num_advertised_ssids", 1, _
        "dot11.device.advertised_ssid_map", $oSSIDMap _
    )

    ; Channel as string (Kismet stores channel as string)
    Local $sChannel = String($channel)

    ; Frequency info
    Local $oFreqMap = _JSONObject(String($iFreqKhz), 1)

    ; Create the Base Device Object and nest the Dot11 Object
    ; Include Vistumbler-specific radio type (custom extension, ignored by Kismet)
    ; Build device JSON (include Vistumbler radio type even if empty to avoid duplicated branches)
    Local $oDev = _JSONObject( _
        "kismet.device.base.key", $devkey, _
        "kismet.device.base.macaddr", $devmac, _
        "kismet.device.base.name", $ssid, _
        "kismet.device.base.phyname", $phyname, _
        "kismet.device.base.manuf", $manuf, _
        "kismet.device.base.channel", $sChannel, _
        "kismet.device.base.frequency", $iFreqKhz, _
        "kismet.device.base.freq_khz_map", $oFreqMap, _
        "kismet.device.base.crypt_string", $encryption, _
        "kismet.device.base.type", $type, _
        "kismet.device.base.commonname", $ssid, _
        "vistumbler.device.radio_type", $sRadioType, _
        "dot11.device", $oDot11 _
    )

    Return _JSONEncode($oDev)
EndFunc

; ===============================================================================================================================
; Function Name:    _KismetDB_GenerateDeviceJSON_Multi
; Description:      Generates a device JSON blob supporting multiple SSID/auth entries per BSSID.
;                   Each entry in the arrays represents a unique Vistumbler AP (same BSSID, different SSID/auth/encr/chan).
; Parameters:       $devkey      - Device key (typically BSSID)
;                   $devmac      - Device MAC address
;                   $type        - Device type ("Wi-Fi AP", "Wi-Fi Ad-Hoc")
;                   $phyname     - PHY name ("IEEE802.11")
;                   $manuf       - Manufacturer string
;                   $sRadioType  - Radio type string (Vistumbler custom field)
;                   $aSSIDs      - Array of SSID strings
;                   $aChannels   - Array of channel numbers
;                   $aEncryptions - Array of "Auth/Encr" strings
;                   $aCryptSets  - Array of crypt_set bitfield values
;                   $aFreqsKhz  - Array of frequency values in KHz
; Returns:          JSON string
; ===============================================================================================================================
Func _KismetDB_GenerateDeviceJSON_Multi($devkey, $devmac, $type, $phyname, $manuf, $sRadioType, $aSSIDs, $aChannels, $aEncryptions, $aCryptSets, $aFreqsKhz)
    Local $iEntryCount = UBound($aSSIDs)

    ; Build the advertised_ssid_map with one entry per AP variant
    ; Start with an empty JSON object for the map
    Local $oSSIDMap[1][2] = [[$_JSONNull, 'JSONObject']]
    Local $oFirstSSIDRecord = 0
    Local $sFirstSSID = ""
    Local $iFirstCsum = 0

    For $e = 0 To $iEntryCount - 1
        Local $sEntrySSID = $aSSIDs[$e]
        Local $iEntryChan = $aChannels[$e]
        Local $sEntryEncr = $aEncryptions[$e]
        Local $iEntryCrypt = $aCryptSets[$e]

        ; Compute a unique checksum key that includes SSID + channel + encryption
        ; so same-SSID entries with different auth/channel get unique keys
        Local $sHashInput = $sEntrySSID & "|" & $iEntryChan & "|" & $sEntryEncr
        Local $iCsum = 0
        For $c = 1 To StringLen($sHashInput)
            $iCsum = BitXOR($iCsum * 31, Asc(StringMid($sHashInput, $c, 1)))
        Next
        If $iCsum < 0 Then $iCsum = $iCsum * -1
        Local $sCsumKey = String($iCsum)

        ; Create the SSID record for this entry (includes crypt_string for reimport)
        Local $oSSIDRec = _JSONObject( _
            "dot11.advertisedssid.ssid", $sEntrySSID, _
            "dot11.advertisedssid.ssidlen", StringLen($sEntrySSID), _
            "dot11.advertisedssid.ssid_len", StringLen($sEntrySSID), _
            "dot11.advertisedssid.length", StringLen($sEntrySSID), _
            "dot11.advertisedssid.crypt_set", $iEntryCrypt, _
            "dot11.advertisedssid.crypt_bitfield", $iEntryCrypt, _
            "dot11.advertisedssid.channel", String($iEntryChan), _
            "dot11.advertisedssid.crypt_string", $sEntryEncr, _
            "dot11.advertisedssid.beacon_info", "", _
            "dot11.advertisedssid.first_time", 0, _
            "dot11.advertisedssid.last_time", 0 _
        )

        ; Add this entry to the SSID map
        Local $iMapSize = UBound($oSSIDMap)
        ReDim $oSSIDMap[$iMapSize + 1][2]
        $oSSIDMap[$iMapSize][0] = $sCsumKey
        $oSSIDMap[$iMapSize][1] = $oSSIDRec

        ; Track the first entry for last_beaconed_ssid
        If $e = 0 Then
            $oFirstSSIDRecord = $oSSIDRec
            $sFirstSSID = $sEntrySSID
            $iFirstCsum = $iCsum
        EndIf
    Next

    ; Create the Dot11 Device Object
    Local $oDot11 = _JSONObject( _
        "dot11.device.last_beaconed_ssid", $sFirstSSID, _
        "dot11.device.last_beaconed_ssid_record", $oFirstSSIDRecord, _
        "dot11.device.last_beaconed_ssid_checksum", $iFirstCsum, _
        "dot11.device.num_advertised_ssids", $iEntryCount, _
        "dot11.device.advertised_ssid_map", $oSSIDMap _
    )

    ; Use first entry's channel and frequency for the base device
    Local $sChannel = String($aChannels[0])
    Local $iFreqKhz = $aFreqsKhz[0]
    Local $oFreqMap[1][2] = [[$_JSONNull, 'JSONObject']]
    ; Add all unique frequencies to the freq map
    For $e = 0 To $iEntryCount - 1
        Local $sFreqKey = String($aFreqsKhz[$e])
        ; Check if already in map
        Local $bFreqFound = False
        For $f = 1 To UBound($oFreqMap) - 1
            If $oFreqMap[$f][0] == $sFreqKey Then
                $bFreqFound = True
                ExitLoop
            EndIf
        Next
        If Not $bFreqFound Then
            Local $iFmSize = UBound($oFreqMap)
            ReDim $oFreqMap[$iFmSize + 1][2]
            $oFreqMap[$iFmSize][0] = $sFreqKey
            $oFreqMap[$iFmSize][1] = 1
        EndIf
    Next

    ; Combined crypt_string (use first entry's; on reimport each SSID map entry has its own)
    Local $sCombinedCrypt = $aEncryptions[0]

    ; Build the base device object
    Local $oDev = _JSONObject( _
        "kismet.device.base.key", $devkey, _
        "kismet.device.base.macaddr", $devmac, _
        "kismet.device.base.name", $sFirstSSID, _
        "kismet.device.base.phyname", $phyname, _
        "kismet.device.base.manuf", $manuf, _
        "kismet.device.base.channel", $sChannel, _
        "kismet.device.base.frequency", $iFreqKhz, _
        "kismet.device.base.freq_khz_map", $oFreqMap, _
        "kismet.device.base.crypt_string", $sCombinedCrypt, _
        "kismet.device.base.type", $type, _
        "kismet.device.base.commonname", $sFirstSSID, _
        "vistumbler.device.radio_type", $sRadioType, _
        "dot11.device", $oDot11 _
    )

    Return _JSONEncode($oDev)
EndFunc
