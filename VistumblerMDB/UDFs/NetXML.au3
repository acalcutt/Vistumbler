#include-once
#include <Date.au3>

; #INDEX# =======================================================================================================================
; Title .........: NetXML Library
; AutoIt Version : 3.3.14.0+
; Description ...: Functions for writing NetXML (.netxml) files
; Author(s) .....: Generated by Copilot
; ===============================================================================================================================

Global $__sNetXML_Content = ""

; ===============================================================================================================================
; Function Name:    _NetXML_Create
; Description:      Initializes the NetXML content
; ===============================================================================================================================
Func _NetXML_Create($sVersion = "0.1")
    $__sNetXML_Content = '<?xml version="1.0" encoding="ISO-8859-1"?>' & @CRLF
    $__sNetXML_Content &= '<!DOCTYPE detection-run SYSTEM "http://kismetwireless.net/kismet-3.1.0.dtd">' & @CRLF
    $__sNetXML_Content &= '<detection-run kismet-version="Vistumbler" start-time="' & _NetXML_FormatDate(_NowCalc()) & '">' & @CRLF
    $__sNetXML_Content &= '<card-source uuid="00000000-0000-0000-0000-000000000000">vistumbler</card-source>' & @CRLF
EndFunc

; ===============================================================================================================================
; Function Name:    _NetXML_AddNetwork
; Description:      Adds a wireless-network entry
; ===============================================================================================================================
Func _NetXML_AddNetwork($bssid, $ssid, $manuf, $channel, $freq, $type, $encrypt, $essid_cloaked, $first_time, $last_time, $max_rate, $max_signal, $min_signal, $max_signal_history, $datasize, $gps_lat, $gps_lon, $gps_alt, $gps_speed, $last_rssi = 0, $min_rssi = 0, $max_rssi = 0)
    ; Calculate frequency if missing
    If Number($freq) <= 0 Then $freq = _NetXML_GetFreqFromChannel($channel)
    
    ; Formatting dates to Kismet format (Day Mon DD HH:MM:SS YYYY)
    $first_time = _NetXML_FormatDate($first_time)
    $last_time = _NetXML_FormatDate($last_time)

    Local $sNet = '<wireless-network number="0" type="' & $type & '" first-time="' & $first_time & '" last-time="' & $last_time & '">' & @CRLF
    $sNet &= '  <SSID first-time="' & $first_time & '" last-time="' & $last_time & '">' & @CRLF
    $sNet &= '    <type>' & $type & '</type>' & @CRLF
    $sNet &= '    <max-rate>' & $max_rate & '</max-rate>' & @CRLF
    $sNet &= '    <packets>0</packets>' & @CRLF
    $sNet &= '    <beaconrate>10</beaconrate>' & @CRLF
    $sNet &= '    <encryption>' & $encrypt & '</encryption>' & @CRLF
    $sNet &= '    <essid cloaked="' & $essid_cloaked & '">' & _XMLEncode($ssid) & '</essid>' & @CRLF
    $sNet &= '  </SSID>' & @CRLF
    $sNet &= '  <BSSID>' & $bssid & '</BSSID>' & @CRLF
    $sNet &= '  <manuf>' & _XMLEncode($manuf) & '</manuf>' & @CRLF
    $sNet &= '  <channel>' & $channel & '</channel>' & @CRLF
    $sNet &= '  <freqmhz>' & $freq & ' 0</freqmhz>' & @CRLF
    $sNet &= '  <maxseenrate>' & $max_rate & '</maxseenrate>' & @CRLF
    $sNet &= '  <snr-info>' & @CRLF
    $sNet &= '    <last_signal_dbm>' & $last_rssi & '</last_signal_dbm>' & @CRLF
    $sNet &= '    <last_noise_dbm>0</last_noise_dbm>' & @CRLF
    $sNet &= '    <last_signal_rssi>' & $last_rssi & '</last_signal_rssi>' & @CRLF
    $sNet &= '    <last_noise_rssi>0</last_noise_rssi>' & @CRLF
    $sNet &= '    <min_signal_dbm>' & $min_rssi & '</min_signal_dbm>' & @CRLF
    $sNet &= '    <min_noise_dbm>0</min_noise_dbm>' & @CRLF
    $sNet &= '    <min_signal_rssi>' & $min_rssi & '</min_signal_rssi>' & @CRLF
    $sNet &= '    <min_noise_rssi>0</min_noise_rssi>' & @CRLF
    $sNet &= '    <max_signal_dbm>' & $max_rssi & '</max_signal_dbm>' & @CRLF
    $sNet &= '    <max_noise_dbm>0</max_noise_dbm>' & @CRLF
    $sNet &= '    <max_signal_rssi>' & $max_rssi & '</max_signal_rssi>' & @CRLF
    $sNet &= '    <max_noise_rssi>0</max_noise_rssi>' & @CRLF
    $sNet &= '  </snr-info>' & @CRLF
    
    If $gps_lat <> 0 Or $gps_lon <> 0 Then
        $sNet &= '  <gps-info>' & @CRLF
        $sNet &= '    <min-lat>' & $gps_lat & '</min-lat>' & @CRLF
        $sNet &= '    <min-lon>' & $gps_lon & '</min-lon>' & @CRLF
        $sNet &= '    <min-alt>' & $gps_alt & '</min-alt>' & @CRLF
        $sNet &= '    <min-spd>' & $gps_speed & '</min-spd>' & @CRLF
        $sNet &= '    <max-lat>' & $gps_lat & '</max-lat>' & @CRLF
        $sNet &= '    <max-lon>' & $gps_lon & '</max-lon>' & @CRLF
        $sNet &= '    <max-alt>' & $gps_alt & '</max-alt>' & @CRLF
        $sNet &= '    <max-spd>' & $gps_speed & '</max-spd>' & @CRLF
        $sNet &= '    <peak-lat>' & $gps_lat & '</peak-lat>' & @CRLF
        $sNet &= '    <peak-lon>' & $gps_lon & '</peak-lon>' & @CRLF
        $sNet &= '    <peak-alt>' & $gps_alt & '</peak-alt>' & @CRLF
        $sNet &= '    <peak-spd>' & $gps_speed & '</peak-spd>' & @CRLF
        $sNet &= '    <avg-lat>' & $gps_lat & '</avg-lat>' & @CRLF
        $sNet &= '    <avg-lon>' & $gps_lon & '</avg-lon>' & @CRLF
        $sNet &= '    <avg-alt>' & $gps_alt & '</avg-alt>' & @CRLF
        $sNet &= '    <avg-spd>' & $gps_speed & '</avg-spd>' & @CRLF
        $sNet &= '  </gps-info>' & @CRLF
    EndIf

    $sNet &= '  <datasize>' & $datasize & '</datasize>' & @CRLF
    $sNet &= '</wireless-network>' & @CRLF
    
    $__sNetXML_Content &= $sNet
EndFunc

; ===============================================================================================================================
; Function Name:    _NetXML_Save
; Description:      Saves the NetXML content to a file
; ===============================================================================================================================
Func _NetXML_Save($sFilePath)
    $__sNetXML_Content &= '</detection-run>'
    Local $hFile = FileOpen($sFilePath, 2 + 8) ; Overwrite + Create Dir
    If $hFile = -1 Then
        SetError(1)
        Return False
    EndIf
    FileWrite($hFile, $__sNetXML_Content)
    FileClose($hFile)
    Return True
EndFunc

; ===============================================================================================================================
; Function Name:    _XMLEncode
; Description:      Encodes special characters for XML
; ===============================================================================================================================
Func _XMLEncode($sString)
    $sString = StringReplace($sString, "&", "&amp;")
    $sString = StringReplace($sString, "<", "&lt;")
    $sString = StringReplace($sString, ">", "&gt;")
    $sString = StringReplace($sString, '"', "&quot;")
    $sString = StringReplace($sString, "'", "&apos;")
    Return $sString
EndFunc

; ===============================================================================================================================
; Function Name:    _NetXML_GetFreqFromChannel
; Description:      Calculates Frequency (MHz) from Channel Number
; ===============================================================================================================================
Func _NetXML_GetFreqFromChannel($iChannel)
    $iChannel = Int($iChannel)
    
    ; 2.4 GHz
    If $iChannel >= 1 And $iChannel <= 13 Then
        Return 2407 + ($iChannel * 5)
    ElseIf $iChannel = 14 Then
        Return 2484
    EndIf
    
    ; 5 GHz (UNII-1, 2, 2e, 3) - 5000 + 5*n
    If $iChannel >= 36 And $iChannel <= 177 Then
        Return 5000 + ($iChannel * 5)
    EndIf
    
    ; 6 GHz (HE/EHT)
    If $iChannel >= 1 And $iChannel <= 233 Then
         ; If it falls in 6GHz range ? 
         ; Note: Channel 1 overlaps with 2.4GHz index if not careful. 
         ; But Vistumbler typically inputs standard channel numbers. 
         ; 6GHz starting Freq 5950 + 5*n
         If $iChannel = 1 Or $iChannel = 5 Or $iChannel = 9 Then
              ; This is ambiguous with 2.4GHz. 
              ; Vistumbler usually tracks band. But here we only have channel.
              ; Optimization: Assume it is 2.4GHz if < 14 unless explicitly indicated (which we can't tell).
              ; So only return 6GHz if > 177 which is rare but possible? 
              ; Actually standard 6GHz channels align with 5GHz numbering continuation conceptually or reuse low numbers.
              ; 6GHz op class global operating classes.
              ; For now, just handle 2.4 and 5 common.
         EndIf
    EndIf
    
    Return 0
EndFunc

; ===============================================================================================================================
; Function Name:    _NetXML_FormatDate
; Description:      Formats date string to Kismet format: Mon Dec 12 13:17:58 2016
; Parameter(s):     $sDT - Date Time string in YYYY/MM/DD HH:MM:SS format
; ===============================================================================================================================
Func _NetXML_FormatDate($sDT)
    ; Check if already processed or invalid
    If StringLen($sDT) < 10 Then Return $sDT
    
    ; Expected Input: YYYY/MM/DD HH:MM:SS (standard Vistumbler/AutoIt format)
    $sDT = StringReplace($sDT, "-", "/")
    Local $aSplit = StringSplit($sDT, " ")
    
    If $aSplit[0] < 2 Then Return $sDT
    
    Local $sDatePart = $aSplit[1]
    Local $sTimePart = $aSplit[2]

    ; Remove milliseconds if present (HH:MM:SS.mss)
    If StringInStr($sTimePart, ".") Then
        $sTimePart = StringLeft($sTimePart, StringInStr($sTimePart, ".") - 1)
    EndIf
    
    Local $aD = StringSplit($sDatePart, "/")
    If $aD[0] < 3 Then Return $sDT
    
    Local $sY = $aD[1]
    Local $sM = $aD[2]
    Local $sD = $aD[3]
    
    ; Day of Week (1=Sun)
    Local $iDoW = _DateToDayOfWeek($sY, $sM, $sD) 
    Local $aDays = StringSplit("Sun,Mon,Tue,Wed,Thu,Fri,Sat", ",")
    Local $sDayName = $aDays[$iDoW]
    
    ; Month Name
    Local $aMons = StringSplit("Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec", ",")
    Local $sMonName = $aMons[Number($sM)]
    
    ; Output: Mon Dec 12 13:17:58 2016
    Return $sDayName & " " & $sMonName & " " & $sD & " " & $sTimePart & " " & $sY
EndFunc
